#include "music.h"
#include "motor.h"
#include "servo.h"
#include "helper.h"

#include <string.h>

// tones generated by https://github.com/LenShustek/miditones
#define PROGMEM static
#include "badapple.h"
#include "icecream.h"
#include "megalovania.h"
#include "spiderdance.h"
#include "stillalive.h"

typedef enum {
  MUSIC_STATE_STOP,
  MUSIC_STATE_PLAY,
} music_state_E;

typedef struct {
  const char name[16];
  const uint8_t *data;
  uint32_t length;
} music_score_S;

static music_state_E music_state;
static uint32_t music_position;
static uint32_t music_delay;

#define ADD_SCORE(name) { #name, name##_score, sizeof(name##_score) }
static uint32_t music_current;
static music_score_S music_scores[] = {
  ADD_SCORE(badapple),
  ADD_SCORE(icecream),
  ADD_SCORE(megalovania),
  ADD_SCORE(spiderdance),
  ADD_SCORE(stillalive),
};

static double music_toFreq(uint8_t note);

void music_init(void) {
  music_state = MUSIC_STATE_STOP;
  music_position = 0;
  music_delay = 0;
  music_current = 0;
}

void music_run(void) {
  if(ARR_SIZE(music_scores) == 0) return;
  switch(music_state) {
    case MUSIC_STATE_PLAY:
    {
      if(music_delay > 0) {
        music_delay--;
        break;
      }

      music_score_S *score = &music_scores[music_current];
      const uint8_t cmd = score->data[music_position++];

      if(cmd == 0xF0) { // end of score
        music_stop();

      } else if(cmd == 0xE0) { // end of score, restart
        music_position = 0;

      } else if((cmd & 0xF0) == 0x90) { // play note
        uint8_t generator = cmd & 0x0F;
        if(generator < MOTOR_COUNT) {
          motor_buzz(generator, music_toFreq(score->data[music_position++]));
        } else if(generator == MOTOR_COUNT) {
          servo_lock(S2, !servo_isLocked(S2));
        }

      } else if((cmd & 0xF0) == 0x80) { // stop note
        uint8_t generator = cmd & 0x0F;
        if(generator < MOTOR_COUNT) {
          motor_stop(generator);
        }

      } else if((cmd & 0xF0) == 0x00) { // delay
        music_delay = (cmd & 0x0F) << 8;
        music_delay |= score->data[music_position++];
      }

      if(music_position >= score->length) {
        music_stop();
      }

      break;
    }

    default:
      break;
  }
}

void music_play(const char *name) {
  if(name == NULL) {
      music_state = MUSIC_STATE_PLAY;
  } else {
    for(uint32_t i = 0; i < ARR_SIZE(music_scores); i++) {
      if(strcmp(music_scores[i].name, name) == 0) {
        if(music_current != i) {
          music_position = 0;
        }
        music_current = i;
        music_state = MUSIC_STATE_PLAY;
        break;
      }
    }
  }
}

void music_pause(void) {
  for(motor_E motor_id = M1; motor_id < MOTOR_COUNT; motor_id++) {
    motor_stop(motor_id);
  }
  music_state = MUSIC_STATE_STOP;
}

void music_stop(void) {
  for(motor_E motor_id = M1; motor_id < MOTOR_COUNT; motor_id++) {
    motor_stop(motor_id);
  }
  music_state = MUSIC_STATE_STOP;
  music_position = 0;
  music_delay = 0;
}

static double music_toFreq(uint8_t note) {
   double freq = pow(2, (note - 69) / 12.0) * 440;
   while(freq < 500) freq *= 2;
   return freq;
}
